# 🌐 浏览器端

## XSS 的概念

### HTML标准

<https://html.spec.whatwg.org/>

#### 开放元素堆栈（Stack of open elements）

#### 名字空间（Namespace）

HTML、SVG、MathML


## 常用注入方法

### JS 注入

#### 偷 cookie


#### 请求伪造


### HTML 注入


### 使用iframe的XSS

在比较难的XSS题目中，经常会需要在攻击者的页面中通过一个或多个iframe载入目标页面，并对这些iframe进行操作。例如idekCTF 2025 jnotes、MaltaCTF 2025 AdBlocker.


### CSS 注入

#### 偷属性数据


#### 偷 Body 数据

连字（Ligatures）\n

不让用远程字体怎么办？

<https://blog.pspaul.de/posts/bench-press-leaking-text-nodes-with-css/>


### DOM Clobbering

dom clobbering介绍：<https://cloud.tencent.com/developer/article/1808582>

document和window对象分别是什么？

假设有一个变量x，则通过`<form name="x">`可以覆盖document.x, window.x, 以及通过var定义的全局变量x，通过`<a id="x">`只能覆盖window.x, 以及通过var定义的全局变量x


dom clobbering需要配合页面里加载的js代码使用，常用js gadget：<https://gmsgadget.com/>

常见gadget成因：

* 将script等元素重新插入（可以绕过strict-dynamic）
* 将属性值作为HTML元素插入 / 拼接进HTML元素中
* 将属性值动态拼接进函数 
* 使用Angular, Vue等包含表达式语言的框架：可以尝试用这个表达式语言来插入script元素
* 用document.scripts来读取页面中的script元素：可以用name属性覆盖掉document.scripts
* 一些给属性赋值的函数可能存在原型链污染：例如axios旧版本的formToJSON函数：<https://gmsgadget.com/gadgets/axios/>


### 原型链污染


### mXSS（突变型XSS）


### CSTI（客户端模板注入）

利用客户端模板引擎，如Angular，Vue.js等

#### AngularJS

AngularJS 通过 ng-directives 扩展 HTML，例如ng-app 指令定义一个 AngularJS 应用程序，允许 AngularJS 处理 HTML 内容，从而在{{}}}内执行 JavaScript 表达式。

```markup
<div ng-app>
    {{constructor.constructor('alert(1)')()}}
    <ANY ng-init="constructor.constructor('alert(2)')()"></ANY>
</div>
```

若存在 CSP 且允许 `https://cdnjs.cloudflare.com`, 则可利用 AngularJS + Prototype 实现 XSS，angularJS提供了CSP兼容模式（ng-csp），在未使用 ng-csp 的情况下 AngularJS 会尝试自动检测 CSP 是否有指定 unsafe-eval，使用 ng-csp 后在CSP模式下仍然可以执行任意js代码。

```markup
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
  <div ng-app ng-csp>
    {{$on.curry.call().alert('xss')}}
  </div>
```

`prototype.js` 为 `Function` 对象添加了 `curry` 方法，在不传入参数时返回 `this`。在非严格模式下，`[call()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call)` 在省略 `thisArg` 时会传入全局对象，也就是将 `window` 对象作为 `this` 传入被调用的函数（curry）中。因此 `$on.curry.call()` 相当于返回 `window` 对象。

```markup
 <script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.3/angular.min.js"></script>
 <div ng-app ng-csp>
    <input id=x autofocus ng-focus=$event.composedPath()|orderBy:'(z=alert)(1)'>
 </div>
```

 ![](https://notes.sjtu.edu.cn/uploads/upload_c20b17dd5270a1dba81b2efc87648d53.png " =494x180")

`composedPath()` 会返回包含 `window` 对象的数组，然后利用 angularjs 提供的过滤器 `[orderBy](https://docs.angularjs.org/api/ng/filter/orderBy)` 对数组中的每个对象执行表达式从而实现 `window.alert`。

## 防御机制

### CSP 策略

参考：<https://content-security-policy.com/>

实现CSP的方法：


1. HTTP响应头`Content-Security-Policy`
2. 在<head>中`<meta http-equiv="Content-Security-Policy" content="default-src 'none';...">`
3. `<iframe>`标签的`csp`属性

   \

比较特殊的CSP属性：

`'nonce-WUAok...'` 允许为每个请求提供一个随机生成的唯一值，称为"nonce"。将这个值放入 CSP 头部后，会要求所有内联脚本必须带有包含相同随机 nonce 值的 nonce= 属性。攻击者无法预先生成这个随机值，因此无法预测其恶意脚本所需的 nonce= 属性值。


绕过`script-src 'self'`的方法：


1. 寻找文件上传接口，上传JavaScript文件（后缀名任意，参考MIME sniffing）
2. 寻找有回显的路由（内容反射点），例如有个报错页面会把访问的不存在的路径打印出来，那就在路径里包含JavaScript代码。jsonp接口也可以，常见网站的jsonp endpoints：<https://github.com/zigoo0/JSONBee>   （对于jsonp限制特殊字符时，可以考虑`Same Origin Method Execution`，找同源网站下的方法：`document.body.firstElementChild.nextElementSibling.click`
3. 如果是聊天室之类的应用并且使用了Socket.IO库，存在可利用的gadget，可以构造出包含JavaScript代码的URI，参考： <https://jorianwoltjer.com/blog/p/ctf/intigriti-xss-challenge/0725#csp-bypass-using-socket-io>


其余绕过：


1. 对于CSP的script-src中的URL限制，如果允许的站点里存在open redirect漏洞，则可以绕过其余URL的path部分  <https://aszx87410.github.io/beyond-xss/ch2/csp-bypass/#%E7%B6%93%E7%94%B1%E9%87%8D%E6%96%B0%E5%B0%8E%E5%90%91%E7%9A%84%E7%B9%9E%E9%81%8E>
2. （部分后端）URL编码绕过path限制：CSP允许的路径是 `https://example.com/scripts/react/`，可以这样绕过：

   `<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>`

### CSRF Token

### Same-Site 策略

### Cookie 的各种策略

### CORS 策略

### HTML Sanitizers

每个sanitizer的净化流程？老版本有哪些漏洞？最新版本下有哪些配置不当/使用不当导致的漏洞？

方便测试用： <https://yeswehack.github.io/Dom-Explorer/>

#### DOMPurify

<https://mizu.re/post/exploring-the-dompurify-library-hunting-for-misconfigurations>

绕过方法：


1. 寻找DOM Clobbering有没有能用的gadget，因为HTML Sanitizer防不了DOM Clobbering
2. 尝试通过多次分开注入的方法绕过，例如第一次注入一个`<iframe id="chat-message">`元素，用DOM Clobbering替代掉本该注入到的div块，第二次在这个<iframe>中注入一个`<a id="</iframe><img src onerror=alert(origin)>">`，提前闭合掉iframe元素，从而注入XSS
3. 寻找使用DOMPurify时的配置不当，例如允许了`data-*, aria-*`这类属性，或者设置了自定义的钩子（很可能导致漏洞）

#### JSoup

#### Angular Sanitizer

#### Ammonia


### WAF


\

## 特殊绕过方法

* 响应头缺少charset时，编码绕过：<https://www.sonarsource.com/blog/encoding-differentials-why-charset-matters/>


* Shadow DOM 绕过 querySelector()
* .innerHTML不会执行动态插入的script元素的代码：改用img的onerror，或者将其包裹在 `<iframe srcdoc="...">` 中，创建一个能加载 script 标签的新文档:

  ```python
  document.body.innerHTML = '<iframe srcdoc="&lt;script>alert(1)&lt;/script>"></iframe>'
  ```
* PHP的报错可以触发XSS
* 与文件上传相结合：如果能上传任意后缀名的文件，可以直接传html文件；如果只能上传.jpg文件，文件名完全不可控，还可以考虑结合路径穿越漏洞来欺骗前端js代码自动请求的后端API，例如本来js会请求`/api/userData/用户名`， 我们把用户名设置为`../../../uploads/1.jpg`，并且上传一个包含指定的json格式数据的1.jpg，就能够伪造后端返回的数据（2025 idek CTF SHEkssss）


## 其他攻击手段

实际CTF比赛用不到，但是作为拓展阅读很有趣

### Clickjacking

### Cookie tossing

### Cookie bomb

### MIME sniffing

响应头 X-Content-Type-Options: nosniff

### 供应链攻击

### XSLeaks

### STTF

### HTTP请求走私

参考：<https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn>

<https://www.freebuf.com/articles/web/243652.html>  <https://developer.aliyun.com/article/1617754>

如何走私：CRLF注入；CL.TE/TE.CL；H2.CL/H2.TE；Fat GET…

能够导致：响应队列投毒，升级XSS…


## 参考资料

<https://blog.huli.tw/2022/09/29/css-injection-1/>

<https://aszx87410.github.io/beyond-xss/>